## Bonk


```
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⢀⣔⢧⣓⢖⡮⣎⢮⢣⡫⡂⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠄⢠⡺⣧⣳⢵⡳⡝⡎⣎⢇⢏⢎⢲⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⡠⡄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⠄⠄⠄⡀⡧⣫⡳⡳⡓⡝⢚⢻⢽⢺⢼⢼⢼⡁⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠠⣀⢀⠄⠄⣠⢪⢣⠊⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⠄⢀⢠⡪⣞⣝⣞⢮⡳⡱⢌⢂⠢⡑⡸⡸⡹⣝⡾⣄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣀⡱⡀⠈⠄⡀⡮⡪⠊⠄⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⠄⢠⢞⣜⢮⢮⢺⢜⢷⢽⢮⢇⢇⢕⢵⡧⣇⢇⢗⡿⡻⠄⠄⠄⠄⠄⠄⢠⠄⢄⠈⠂⠄⢀⢖⢝⠜⠄⠄⡀⠄⠄⠄⠄⠄⠄⠄⠄
⠄⠄⡠⢯⢯⡺⡧⣳⡱⢍⠇⡏⢎⠫⡢⢊⠜⢜⢕⠝⠁⠄⠄⠄⠄⠄⠄⣀⢄⠈⠢⠜⠄⢀⢔⢇⡯⣢⢆⡶⡤⣄⡀⡐⠄⠁⠄⠐⠄⠄
⠄⢠⣝⢵⡫⡿⣝⢮⡪⡣⡓⠜⢔⢑⠌⢔⠨⢂⠢⠡⠄⠄⠄⠄⠄⠄⠄⠙⢆⠅⠄⠄⡆⡧⣫⡺⡼⡪⢷⢽⢯⣗⢯⡆⡄⠄⠄⠄⠄⠄
⠄⣞⢾⢵⡫⡯⣗⣝⢮⢢⠪⡘⡐⢅⢊⠔⡨⠢⡑⡅⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢀⢮⣺⢽⢳⡹⡰⡨⠪⡽⣕⢯⡳⣝⡦⡀⠄⠄⡀⠄
⠄⣞⢽⣝⢮⢯⣺⢮⣳⡳⡵⡸⡨⡢⣑⢑⢌⢎⠪⡢⠄⠄⠄⠄⠄⠄⠄⠄⢠⠪⣳⣟⢮⢳⢕⣽⢪⢘⢜⢜⢮⡳⡽⣕⡯⣖⠄⠄⠄⠄
⠄⠘⣝⢮⢯⣳⣳⣻⣺⡪⣳⢱⢱⢸⢰⢵⡕⡔⡑⡌⡀⠄⠄⠄⠄⠄⢀⠦⠃⠁⢻⣽⢕⣗⡽⡳⡱⡐⢕⢕⡳⡽⣝⡮⣯⡺⣕⡀⠄⠄
⠄⠄⠈⠹⢳⣳⣻⣞⡧⣏⢮⢪⠪⡪⡪⡳⡽⣰⢨⢊⠪⠪⠢⡢⢄⢔⠍⠄⠄⠄⠈⠈⢑⢗⠝⢜⠰⡘⣜⢼⣝⣞⣗⢯⡳⣝⢮⢆⠄⠄
⠄⠄⠄⠄⠄⠈⠘⠷⢟⢮⡳⡱⣑⢌⠪⠨⠪⠺⠸⡨⡢⢄⣀⢰⠍⠄⠄⠄⠄⠄⠄⡀⢘⢌⢎⠪⡪⡪⡮⣗⢗⣗⢽⢕⢯⢮⡳⣯⠄⠄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠙⡮⡣⡁⠄⠄⠄⠄⠄⠄⠈⠨⡢⡪⠢⠋⠄⠄⠄⠄⠄⠁⠄⠨⡢⡑⡅⢕⠕⣕⢳⢹⢸⢪⢳⡹⡮⡯⡷⡅⠄
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⢯⢎⢆⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠁⠄⠄⠄⠄⠈⠄⠄⠄⠈⠂⠑⠘⠐⠑⠘⠘⠘⠘⠘⠊⠙⠙⠙⠋⠃⠄
```

This is a very portable binary. It installs its config file and its own rules


## TODO

> Refactor pkg/bonk/util.go

[x] - Add function labelling PID as bonkable
[ ] - Add function labelling IP as bonkable
[x] - Remove unneeded util.go files
[ ] - Refactor pkg/bonk/net.go
[ ] - Either gut parser.go or finish interface
[ ] - Finish documentation

[ ] - Make Code Pretty 

## ABOUT

Turns linux kernel audit features into a death weapon.
You violate the bonk you must be bonked.

The principle is simple. Utilize the linux auditd logging feature to listen in on all system calls to the kernel. Any rule outlined and embedded within the binary will be streamed through `stream.go`. Then, depending on how the program is configured, one of the following will occur (note these are examples):
1) A malicious process launches a rule that is deemed `bonkable`. `bonk` will find the PID associated with the process and ensure the UID is not an allowed user and kill it
2) An IP banned connects. The daemon notices suspicious activities, checks IP of PID, and determines the PID needs to be turned off
etc.

Essentially:
`rule tripped` -> `[internal logic]` -> `[kill process / ignore]`

Currently the following methods of determining whether a PID should be killed can be determined via
[x] violation of rule put in `bonkable` in config.json
[ ] deny by ip - if IP of PID is from known bad source, kill it no matter what
[ ] allow by ip - if IP of PID is from known good source, do not kill it
[ ] `bonks-before-ban` - checks number of violations of IP address before banned - TODO see if should included

FUTURE PLANS:
[ ] Yara integration so that `/proc/<PID>/exe` can be checked if there is malware detected ( essentially making this a antivirus for linux)


## How to run

This launches the simplest version of bonk with verbose logs on.
```
git clone github.com/KevOub/bonk/cmd
cd cmd
go build bonk2.go # TODO rename this file
sudo ./bonk2
```

[ ] - TODO make the cmd version include flags so that this is capable of being a legit release




### Files it creates

[ ] TODO ensure these are right


> /etc/bonk/config.json

The configuration file

> /var/log/bonk/(bonk.log,bonk-verbose.log,logs)

The logs stored for future lookup


### Modes of operation

```go
const (
	LOAD        BonkOperation = iota // Operation for loading rules
	LOCKANDLOAD                      // Bad name for loading rules then using bonk
	DELETE                           // Operation for deleting all rules
	HONK                             // Operation for showing what would be killed but doesn't
	BONK                             // Kill violations
)
```

> load

yells at kernel to add rule, exits. Takes a while 

> lockandload


yells at kernel to add rule, exits. Immediately goes into `bonk` mode after

> bonk

Listens to auditd log stream. Checks against the `config.json` file to see allowed users (if you remove root / current user / unset bonk will just kill itself).
If the syscall is naughty, exterminate

> honk

Labels processes as would be killed instead of actually killing them

>bonkip-a / bonkip-b

looks at the process table to get the IP address and compares it against that of the config. If it violates it either tells you or **bonks** it.



## BACKEND

- config.go
      The config stuff just works. Suggestions allowed

- parser.go 
      Hacky solution to handle uncertainty of log format. Implemented sample interface to alievate rewriting it into future releases

```go
type Parser interface {
	IsNewAuditID(line string) bool
	InitAuditMessage(line string) error
	ParseAuditRuleRegex(rules *regexp.Regexp, msg string, remove string) string
}
```

essentially, implement those three functions and let me finish rewriting the functions to take interfaces 
should allow us to be golden
